# -*- coding: utf-8 -*-

"""
/***************************************************************************
 a
                                 A QGIS plugin
 v
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-10-02
        copyright            : (C) 2025 by fdfdfdfdfdfd
        email                : perdas@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'fdfdfdfdfdfd'
__date__ = '2025-10-02'
__copyright__ = '(C) 2025 by fdfdfdfdfdfd'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)
from .Organizadorlotes import OrganizadorDeLotes

class aAlgorithm(QgsProcessingAlgorithm):
    def __init__(self, iface=None):
        super().__init__()
        self.iface = iface
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
      

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
       

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
       

        # Compute the number of steps to display within the progress bar and
        # get features from source
    

        dlg = OrganizadorDeLotes(self.iface)
        dlg.run()

            # Add a feature in the sink
        

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'b'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'ba'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return aAlgorithm()
ORGANIZAOD DE LOTES:
# -*- coding: utf-8 -*-
"""
OrganizadorDeLotes
A QGIS plugin to organize lots within a block.
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from qgis.gui import QgsMapToolIdentifyFeature
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsFeature, QgsExpression,
    QgsProcessing, QgsProcessingFeedback, QgsMessageLog, Qgis)

from .OrganizadorLotesdialog import OrganizadorDeLotesDialog
import os.path
import processing

class OrganizadorDeLotes:
   
    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.tool = None
        
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            f'OrganizadorDeLotes_{locale}.qm'
        )
        
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)
        
        self.actions = []
        self.menu = self.tr(u'&OrganizadorDeLotes')
        self.first_start = None
        
 
    def tr(self, message):
        return QCoreApplication.translate('OrganizadorDeLotes', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, 
                   add_to_menu=True, add_to_toolbar=True, status_tip=None, 
                   whats_this=None, parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        
        if status_tip is not None:
            action.setStatusTip(status_tip)
        if whats_this is not None:
            action.setWhatsThis(whats_this)
        if add_to_toolbar:
            self.iface.addToolBarIcon(action)
        if add_to_menu:
            self.iface.addPluginToVectorMenu(self.menu, action)
            
        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = os.path.join(self.plugin_dir, 'icon.png')
        self.add_action(
            icon_path,
            text=self.tr(u'Organiza Lote'),
            callback=self.run,
            parent=self.iface.mainWindow()
        )
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginVectorMenu(self.tr(u'&OrganizadorDeLotes'), action)
            self.iface.removeToolBarIcon(action)

    def listar_conexoes_postgis(self):
        settings = QSettings()
        settings.beginGroup('PostgreSQL/connections')
        conexoes = settings.childGroups()
        settings.endGroup()
        return conexoes

    def verificar_ins_quadra_existe(self, conexao, ins_quadra):
        """Verifica se já existe registros na tabela novaordem para a ins_quadra"""
        try:
            # Abordagem mais simples: Tentar buscar um registro específico
            # Se a consulta retornar dados, existe; se não retornar, não existe
            alg_params = {
                'DATABASE': conexao,
                'SQL': f'''
                    SELECT 1 as existe 
                    FROM comercial_umc.novaordem 
                    WHERE ins_quadra = {ins_quadra} 
                    LIMIT 1
                ''',
                'OUTPUT': 'memory:temp_verificacao'
            }
            
            try:
                result = processing.run('native:postgisexecuteandloadsql', alg_params)
                
                # Verificar se a camada de resultado tem features
                output_layer = result['OUTPUT']
                feature_count = output_layer.featureCount()
                
                QgsMessageLog.logMessage(
                    f"Verificação ins_quadra {ins_quadra}: {feature_count} registros encontrados", 
                    'OrganizadorDeLotes', 
                    Qgis.Info
                )
                
                # Se tem features, existem registros na tabela
                return feature_count > 0
                
            except Exception as e_inner:
                QgsMessageLog.logMessage(
                    f"Erro na consulta SQL para ins_quadra {ins_quadra}: {str(e_inner)}", 
                    'OrganizadorDeLotes', 
                    Qgis.Warning
                )
                
                # Se deu erro na consulta, pode ser que a tabela não existe ou está vazia
                # Vamos tentar uma abordagem ainda mais simples
                try:
                    alg_params_simples = {
                        'DATABASE': conexao,
                        'SQL': f'SELECT COUNT(*) FROM comercial_umc.novaordem WHERE ins_quadra = {ins_quadra}'
                    }
                    
                    # Usar apenas postgisexecutesql sem tentar carregar resultado
                    processing.run('native:postgisexecutesql', alg_params_simples)
                    
                    # Se chegou até aqui, a tabela existe
                    # Agora vamos tentar uma consulta que falhe apenas se não houver dados
                    alg_params_teste = {
                        'DATABASE': conexao,
                        'SQL': f'''
                            DO $
                            DECLARE
                                rec_count INTEGER;
                            BEGIN
                                SELECT COUNT(*) INTO rec_count 
                                FROM comercial_umc.novaordem 
                                WHERE ins_quadra = {ins_quadra};
                                
                                IF rec_count = 0 THEN
                                    RAISE EXCEPTION 'NO_RECORDS_FOUND';
                                END IF;
                            END $;
                        '''
                    }
                    
                    processing.run('native:postgisexecutesql', alg_params_teste)
                    
                    # Se chegou até aqui sem erro, existem registros
                    QgsMessageLog.logMessage(
                        f"Registros confirmados para ins_quadra {ins_quadra} via DO block", 
                        'OrganizadorDeLotes', 
                        Qgis.Info
                    )
                    return True
                    
                except Exception as e_do:
                    error_msg = str(e_do).lower()
                    if 'no_records_found' in error_msg:
                        QgsMessageLog.logMessage(
                            f"Nenhum registro encontrado para ins_quadra {ins_quadra}", 
                            'OrganizadorDeLotes', 
                            Qgis.Info
                        )
                        return False
                    else:
                        QgsMessageLog.logMessage(
                            f"Erro no DO block para ins_quadra {ins_quadra}: {str(e_do)}", 
                            'OrganizadorDeLotes', 
                            Qgis.Warning
                        )
                        return False
                
        except Exception as e:
            QgsMessageLog.logMessage(
                f"Erro geral ao verificar ins_quadra {ins_quadra}: {str(e)}", 
                'OrganizadorDeLotes', 
                Qgis.Critical
            )
            # Em caso de erro na verificação, assumir que não existe para ser seguro
            return False

    def excluir_ins_quadra_existente(self, conexao, ins_quadra):
        """
        Exclui TODOS os registros da tabela novaordem onde ins_quadra = valor capturado
        Se existir pelo menos 1 registro com a ins_quadra, TODOS serão excluídos
        """
        try:
            # SQL que exclui TODOS os registros com a ins_quadra capturada
            sql_exclusao = f'DELETE FROM comercial_umc.novaordem WHERE ins_quadra = {ins_quadra}'
            
            QgsMessageLog.logMessage(
                f"Executando SQL de exclusão: {sql_exclusao}", 
                'OrganizadorDeLotes', 
                Qgis.Info
            )
            
            # Usar processing para executar o DELETE na conexão PostgreSQL
            alg_params = {
                'DATABASE': conexao,
                'SQL': sql_exclusao
            }
            
            processing.run('native:postgisexecutesql', alg_params)
            
            QgsMessageLog.logMessage(
                f"TODOS os registros da quadra {ins_quadra} foram excluídos da tabela novaordem com sucesso!", 
                'OrganizadorDeLotes', 
                Qgis.Info
            )
            return True
            
        except Exception as e:
            QgsMessageLog.logMessage(
                f"Erro ao excluir TODOS os registros da ins_quadra {ins_quadra}: {str(e)}", 
                'OrganizadorDeLotes', 
                Qgis.Critical
            )
            return False

    def organizar_ordem_lote(self, conexao, ins_quadra, ordem_primeira, feedback=None):
        results = {}
        try:
            camada_lotes = None
            for layer in QgsProject.instance().mapLayers().values():
                if 'gis_boletim_lote' in layer.name().lower() or 'lote' in layer.name().lower():
                    camada_lotes = layer
                    break
            
            if not camada_lotes:
                raise Exception("Camada de lotes não encontrada no projeto!")

            # Extrair lotes da quadra
            alg_params = {
                'FIELD': 'ins_quadra',
                'INPUT': camada_lotes,
                'OPERATOR': 0,
                'VALUE': str(ins_quadra),
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs = processing.run('native:extractbyattribute', alg_params, feedback=feedback)
            camada_filtrada = outputs['OUTPUT']

            # Calcular offset
            offset = sum(1 for f in camada_filtrada.getFeatures() if f['ordem'] >= ordem_primeira)

            # Recalcular ordem
            expressao_ordem = f'''
                CASE
                    WHEN "ordem" >= {ordem_primeira} THEN "ordem" - ({ordem_primeira} - 1)
                    WHEN "ordem" < {ordem_primeira} THEN "ordem" + {offset}
                END
            '''

            # Garantir que o campo de saída se chama 'n_ordem'
            alg_params = {
                'FIELDS_MAPPING': [
                    {'expression': '"matricula"', 'length': -1, 'name': 'matricula', 'precision': 0, 'type': 2},
                    {'expression': '"ins_quadra"', 'length': -1, 'name': 'ins_quadra', 'precision': 0, 'type': 2},
                    {'expression': expressao_ordem, 'length': -1, 'name': 'n_ordem', 'precision': 0, 'type': 4}
                ],
                'INPUT': camada_filtrada,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs = processing.run('native:refactorfields', alg_params, feedback=feedback)
            camada_processada = outputs['OUTPUT']

            # Exportar para PostgreSQL (tabela 'novaordem', coluna 'n_ordem')
            alg_params = {
                'ADDFIELDS': False,
                'APPEND': True,
                'A_SRS': 'EPSG:31984',
                'CLIP': False,
                'DATABASE': conexao,
                'DIM': 0,
                'GEOCOLUMN': '',
                'GTYPE': 0,
                'INDEX': False,
                'INPUT': camada_processada,
                'LAUNDER': False,
                'MAKEVALID': False,
                'OPTIONS': '',
                'OVERWRITE': False,
                'PK': 'id',
                'PRECISION': True,
                'PROMOTETOMULTI': True,
                'SCHEMA': 'comercial_umc',
                'TABLE': 'novaordem',
            }
            processing.run('gdal:importvectorintopostgisdatabaseavailableconnections', alg_params, feedback=feedback)

            results['success'] = True
            results['message'] = f"Nova ordem atualizada com sucesso!"
            
        except Exception as e:
            results['success'] = False
            results['message'] = f"Erro: {str(e)}"
            QgsMessageLog.logMessage(f"Erro: {str(e)}", 'OrganizadorDeLotes', Qgis.Critical)
            
        return results

    def ativarFerramentaSelecao(self):
        if self.tool is not None:
            self.iface.mapCanvas().unsetMapTool(self.tool)
        
        quadra_layer = None
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == "Quadra":
                quadra_layer = layer
                break
        
        if not quadra_layer:
            QMessageBox.warning(self.dlg, "Aviso", "Camada 'Quadra' não encontrada!")
            return
        
        self.iface.mainWindow().statusBar().showMessage("Clique em uma quadra para selecionar.")
        self.tool = QgsMapToolIdentifyFeature(self.iface.mapCanvas())
        self.tool.setLayer(quadra_layer)
        self.tool.featureIdentified.connect(self.capturarInsQuadra)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.iface.mainWindow().setCursor(Qt.PointingHandCursor)

    def capturarInsQuadra(self, feature):
        if feature.isValid():
            if 'ins_quadra' in feature.fields().names():
                ins_quadra = feature['ins_quadra']
                
                QgsMessageLog.logMessage(
                    f"🎯 Capturando ins_quadra: {ins_quadra} - Preenchendo spinInsQuadra", 
                    'OrganizadorDeLotes', 
                    Qgis.Info
                )
                
                QMessageBox.information(self.dlg, "Quadra Capturada", f"Quadra capturada: {ins_quadra}")
                
                # Preencher o campo spinInsQuadra com valor capturado
                self.dlg.spinInsQuadra.setValue(ins_quadra)
                
                # Log de confirmação
                valor_atual = self.dlg.spinInsQuadra.value()
                QgsMessageLog.logMessage(
                    f"✅ spinInsQuadra definido para: {valor_atual}", 
                    'OrganizadorDeLotes', 
                    Qgis.Info
                )
                
            else:
                QMessageBox.warning(self.dlg, "Erro", "Campo 'ins_quadra' não encontrado na camada 'Quadra'.")
        else:
            QMessageBox.warning(self.dlg, "Erro", "Não foi possível identificar a quadra clicada.")
        
        self.iface.mapCanvas().unsetMapTool(self.tool)
        self.iface.mainWindow().unsetCursor()
        self.tool = None

    def executar_organizacao(self):
        try:
            conexao = self.dlg.cmbConexao.currentText()
            ins_quadra = self.dlg.spinInsQuadra.value()
            ordem_primeira = self.dlg.spinOrdemPrimeira.value()

            if not conexao:
                QMessageBox.warning(self.dlg, "Aviso", "Selecione uma conexão PostgreSQL!")
                return

            # Verificar se uma quadra válida foi selecionada (diferente do valor padrão 99)
            if ins_quadra == 99:
                QMessageBox.warning(self.dlg, "Aviso", "Selecione uma quadra clicando no botão 'Selecionar Quadra'!")
                return

            if ordem_primeira < 1:
                QMessageBox.warning(self.dlg, "Aviso", "A ordem da primeira deve ser maior que 1!")
                return

            resposta = QMessageBox.question(
                self.dlg,
                "Confirmar Operação",
                f"Reorganizar lotes da quadra {ins_quadra} a partir da ordem {ordem_primeira}?\n\n"
                f"ATENÇÃO: Todos os registros existentes da quadra {ins_quadra} na tabela novaordem serão substituídos!",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if resposta == QMessageBox.No:
                return

            feedback = QgsProcessingFeedback()
            self.iface.messageBar().pushMessage(
                "OrganizadorDeLotes", 
                "Processando...", 
                level=Qgis.Info, 
                duration=2
            )
            
            # PASSO 1: SEMPRE excluir registros existentes da ins_quadra
            QgsMessageLog.logMessage(
                f"PASSO 1: Excluindo registros existentes da quadra {ins_quadra}...", 
                'OrganizadorDeLotes', 
                Qgis.Info
            )
            
            if not self.excluir_ins_quadra_existente(conexao, ins_quadra):
                QMessageBox.critical(self.dlg, "Erro", 
                    f"Erro ao excluir registros existentes da quadra {ins_quadra}.\n"
                    "O processo foi interrompido.")
                return
            
            # PASSO 2: Inserir novos registros
            QgsMessageLog.logMessage(
                f"PASSO 2: Inserindo novos registros da quadra {ins_quadra}...", 
                'OrganizadorDeLotes', 
                Qgis.Info
            )
            
            resultados = self.organizar_ordem_lote(conexao, ins_quadra, ordem_primeira, feedback)

            if resultados.get('success', False):
                QMessageBox.information(
                    self.dlg, 
                    "Sucesso", 
                    f"Quadra {ins_quadra} reorganizada com sucesso!\n\n"
                    "✅ Registros antigos excluídos\n"
                    "✅ Nova ordem inserida"
                )
                self.dlg.close()
            else:
                QMessageBox.critical(self.dlg, "Erro", resultados.get('message', 'Erro desconhecido'))
                
        except Exception as e:
            QMessageBox.critical(self.dlg, "Erro", f"Erro durante a execução: {str(e)}")
            QgsMessageLog.logMessage(f"Erro: {str(e)}", 'OrganizadorDeLotes', Qgis.Critical)

    def resetar_valores_plugin(self):
        """Reseta todos os valores armazenados na memória do plugin"""
        try:
            # Resetar ferramenta de seleção
            if self.tool is not None:
                self.iface.mapCanvas().unsetMapTool(self.tool)
                self.tool = None
            
            # Resetar cursor
            self.iface.mainWindow().unsetCursor()
            
            # Limpar status bar
            self.iface.mainWindow().statusBar().clearMessage()
            
            # Se o diálogo já existe, resetar seus valores
            if hasattr(self, 'dlg') and self.dlg is not None:
                # NÃO resetar spinInsQuadra para manter valor padrão do Qt Designer
                # if hasattr(self.dlg, 'spinInsQuadra'):
                #     self.dlg.spinInsQuadra.setValue(0)
                
                # Resetar apenas spinOrdemPrimeira
                if hasattr(self.dlg, 'spinOrdemPrimeira'):
                    self.dlg.spinOrdemPrimeira.setValue(1)
                
                # Resetar combo de conexão para primeiro item
                if hasattr(self.dlg, 'cmbConexao') and self.dlg.cmbConexao.count() > 0:
                    self.dlg.cmbConexao.setCurrentIndex(0)
            
            QgsMessageLog.logMessage(
                "Valores do plugin resetados com sucesso", 
                'OrganizadorDeLotes', 
                Qgis.Info
            )
            
        except Exception as e:
            QgsMessageLog.logMessage(
                f"Erro ao resetar valores: {str(e)}", 
                'OrganizadorDeLotes', 
                Qgis.Warning
            )

    def run(self):
        # SEMPRE resetar valores antes de iniciar o plugin
        self.resetar_valores_plugin()
        
        if self.first_start:
            self.first_start = False
            self.dlg = OrganizadorDeLotesDialog()
            
            if hasattr(self.dlg, 'btnSelecionarQuadra'):
                self.dlg.btnSelecionarQuadra.clicked.connect(self.ativarFerramentaSelecao)
            
            self.dlg.cmbConexao.clear()
            conexoes = self.listar_conexoes_postgis()
            
            if not conexoes:
                QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Nenhuma conexão PostgreSQL encontrada!")
                return
            
            for nome in conexoes:
                self.dlg.cmbConexao.addItem(nome)
            
            if hasattr(self.dlg, 'btnExecutar'):
                self.dlg.btnExecutar.clicked.connect(self.executar_organizacao)
        else:
            # Se não é o primeiro start, NÃO resetar spinInsQuadra para manter valor do Qt Designer
            if hasattr(self, 'dlg') and self.dlg is not None:
                # NÃO resetar spinInsQuadra
                # if hasattr(self.dlg, 'spinInsQuadra'):
                #     self.dlg.spinInsQuadra.setValue(0)
                
                # Resetar apenas spinOrdemPrimeira
                if hasattr(self.dlg, 'spinOrdemPrimeira'):
                    self.dlg.spinOrdemPrimeira.setValue(1)
        
        self.dlg.show()
        result = self.dlg.exec_()
        
        if result:
            self.executar_organizacao()
